using Secp256k1Net;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace ECMH;

public sealed class MultiSet : IDisposable
{
    private const int HASH_SIZE = 32;
    private const int COMPRESSED_POINT_SIZE = 33;
    private const int UNCOMPRESSED_POINT_SIZE = 64;

    private const int HASH_TO_CURVE_PAYLOAD_OFFSET = 8; // nonce
    private const int HASH_TO_CURVE_INPUT_SIZE = HASH_TO_CURVE_PAYLOAD_OFFSET + HASH_SIZE;

    // Compressed point format markers for secp256k1
    private const byte COMPRESSED_Y_EVEN = 0x02;
    private const byte COMPRESSED_Y_ODD = 0x03;

    private static readonly byte[] EMPTY_HASH = new byte[HASH_SIZE];

    private readonly Secp256k1 _secp256k1;
    private readonly byte[] _compressedPoint = new byte[COMPRESSED_POINT_SIZE];
    private readonly byte[] _uncompressedPoint = new byte[UNCOMPRESSED_POINT_SIZE];
    private bool _isInfinity = true;

    public MultiSet()
    {
        _secp256k1 = new Secp256k1();
    }

    /// <summary>
    /// Adds an item's hash to the multiset.
    /// </summary>
    public void AddItem(ReadOnlySpan<byte> sha256Buffer)
    {
        if (sha256Buffer.Length != HASH_SIZE || sha256Buffer.SequenceEqual(EMPTY_HASH))
            return;

        Span<byte> point = stackalloc byte[COMPRESSED_POINT_SIZE];
        if (TryGetPoint(sha256Buffer, point))
            AddPoint(point);
    }

    /// <summary>
    /// Adds the accumulated value of another multiset to this one.
    /// </summary>
    public void AddSet(MultiSet ms)
    {
        if (!ms._isInfinity)
            AddPoint(ms._compressedPoint);
    }

    /// <summary>
    /// Removes an item's hash from the multiset.
    /// </summary>
    public void RemoveItem(ReadOnlySpan<byte> sha256Buffer)
    {
        if (sha256Buffer.Length != HASH_SIZE || sha256Buffer.SequenceEqual(EMPTY_HASH))
            return;

        Span<byte> point = stackalloc byte[COMPRESSED_POINT_SIZE];
        if (TryGetPoint(sha256Buffer, point))
            RemovePoint(point);
    }

    /// <summary>
    /// Removes the accumulated value of another multiset from this one.
    /// </summary>
    public void RemoveSet(MultiSet ms)
    {
        if (!ms._isInfinity)
            RemovePoint(ms._compressedPoint);
    }

    /// <summary>
    /// Gets the final hash of the multiset as a hex string.
    /// </summary>
    public string GetHash()
    {
        return Convert.ToHexString(GetHashBytes());
    }

    public void Dispose()
    {
        _secp256k1.Dispose();
    }

    private void AddPoint(Span<byte> newPoint)
    {
        if (_isInfinity)
        {
            UpdatePoint(newPoint);
            _isInfinity = false;
        }
        else
        {
            // Parse the incoming point into its uncompressed form.
            Span<byte> pubKey2 = stackalloc byte[UNCOMPRESSED_POINT_SIZE];
            if (!_secp256k1.PublicKeyParse(pubKey2, newPoint))
                return; // Should not happen with points generated by TryGetPoint

            // Combine the current accumulator point with the new point.
            Span<byte> result = stackalloc byte[UNCOMPRESSED_POINT_SIZE];
            if (!_secp256k1.PublicKeysCombine(result, _uncompressedPoint, pubKey2))
                throw new InvalidOperationException("Failed to combine points on the curve");

            // Serialize the result back to compressed format.
            Span<byte> newCompressedPoint = stackalloc byte[COMPRESSED_POINT_SIZE];
            if (!_secp256k1.PublicKeySerialize(newCompressedPoint, result, Flags.SECP256K1_EC_COMPRESSED))
                throw new InvalidOperationException("Failed to serialize combined point");

            UpdatePoint(newCompressedPoint);
        }
    }

    private void RemovePoint(ReadOnlySpan<byte> pointToRemove)
    {
        if (pointToRemove.SequenceEqual(_compressedPoint))
        {
            ResetToInfinity();
        }
        else
        {
            // To remove a point P, we add its negation -P.
            // For secp256k1, negating a point (x, y) gives (x, -y).
            // In compressed format, this is achieved by flipping the y-parity bit (0x02 -> 0x03 or vice versa).
            Span<byte> negated = stackalloc byte[COMPRESSED_POINT_SIZE];
            pointToRemove.CopyTo(negated);
            negated[0] ^= 1; // Flips between COMPRESSED_Y_EVEN (2) and COMPRESSED_Y_ODD (3)

            AddPoint(negated);
        }
    }

    /// <summary>
    /// Gets the final hash of the multiset as a byte array.
    /// </summary>
    private byte[] GetHashBytes()
    {
        if (_isInfinity)
            return EMPTY_HASH;

        // The uncompressed point contains two 32-byte coordinates (X and Y).
        // Hashing the raw coordinates provides the final multiset hash.
        Span<byte> uncompressed = stackalloc byte[UNCOMPRESSED_POINT_SIZE];
        _uncompressedPoint.AsSpan().CopyTo(uncompressed);

        // Per the ECMH specification, reverse the byte order of the X and Y coordinates.
        // This is because the coordinates are treated as little-endian integers for the final hash.
        uncompressed[..HASH_SIZE].Reverse();
        uncompressed.Slice(HASH_SIZE, HASH_SIZE).Reverse();

        return SHA256.HashData(uncompressed);
    }

    /// <summary>
    /// Attempts to map a 32-byte hash to a valid point on the secp256k1 curve.
    /// </summary>
    /// <param name="itemHash">The 32-byte hash of the item.</param>
    /// <param name="outputPoint">A 33-byte buffer to write the resulting compressed point to.</param>
    /// <returns>True if a valid point was found and written to the output.</returns>
    private bool TryGetPoint(ReadOnlySpan<byte> itemHash, Span<byte> outputPoint)
    {
        Span<byte> input = stackalloc byte[HASH_TO_CURVE_INPUT_SIZE];
        itemHash.CopyTo(input[HASH_TO_CURVE_PAYLOAD_OFFSET..]);

        Span<byte> hash = stackalloc byte[HASH_SIZE];

        // Iterate with a nonce 'n' until the resulting hash is a valid x-coordinate on the curve.
        for (uint n = 0; n < uint.MaxValue; n++)
        {
            BinaryPrimitives.WriteUInt32LittleEndian(input, n);
            SHA256.HashData(input, hash);

            if (TryCreateValidPoint(hash, outputPoint))
                return true;
        }

        // This is statistically almost impossible but provides a safeguard.
        throw new InvalidOperationException("Failed to find a valid point on the curve after exhausting all nonces");
    }

    /// <summary>
    /// Tries to construct a valid compressed point from a 32-byte x-coordinate hash.
    /// </summary>
    private bool TryCreateValidPoint(ReadOnlySpan<byte> xCoord, Span<byte> output)
    {
        // Determine the y-parity byte (0x02 for even, 0x03 for odd).
        // This choice is arbitrary but must be deterministic. We use the first bit of the hash.
        output[0] = (xCoord[0] & 0x80) == 0 ? COMPRESSED_Y_EVEN : COMPRESSED_Y_ODD;
        xCoord.CopyTo(output[1..]);

        // Verify that this x-coordinate corresponds to a valid point on the curve.
        Span<byte> pubKey = stackalloc byte[UNCOMPRESSED_POINT_SIZE];
        return _secp256k1.PublicKeyParse(pubKey, output);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdatePoint(ReadOnlySpan<byte> newCompressedPoint)
    {
        newCompressedPoint.CopyTo(_compressedPoint);
        if (!_secp256k1.PublicKeyParse(_uncompressedPoint, _compressedPoint))
            throw new InvalidOperationException("Failed to update point");
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetToInfinity()
    {
        Array.Clear(_compressedPoint);
        Array.Clear(_uncompressedPoint);
        _isInfinity = true;
    }
}